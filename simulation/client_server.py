import base64
from ip_functions import ip_str_to_int, ip_int_to_str
from nacl.public import SealedBox
from nacl.public import PublicKey
from nacl.public import PrivateKey
import struct

def create_byte_array(text, length=200, encoding="utf-8", filler_byte=b"\x00"):
    """
    Creates a byte array of a specific length, ensuring the input text fits within it,
    and the last byte is always null (`\x00`).
    - text: The string to include in the byte array.
    - length: The desired total length of the byte array (default is 200 bytes).
    - encoding: The text encoding to use (default is 'utf-8').
    - filler_byte: The byte to use for padding (default is null byte `b"\x00"`).
    """
    # Ensure the array length is at least 1 (to accommodate the null byte)
    if length < 1:
        raise ValueError("Length must be at least 1 to include a null terminator.")
    
    # Convert the text to bytes
    text_bytes = base64.b64encode(bytes(text, 'utf-8'))
    
    # Ensure the text fits within the array, leaving space for the null terminator
    if len(text_bytes) >= length:
        # Truncate the text to length - 1 and add a null byte at the end
        byte_array = text_bytes[:length - 1] + b"\x00"
    else:
        # Add the text, pad with filler bytes, and ensure the last byte is null
        padding_length = length - len(text_bytes) - 1
        byte_array = text_bytes + (filler_byte * padding_length) + b"\x00"
    
    return byte_array

def get_header_values(header):
    """
    Extracts values from the generated header.
    
    Args:
        header (bytes): The binary header generated by `generate_header`.
        
    Returns:
        dict: A dictionary containing the extracted values:
            - "end_flag" (int): The end flag.
            - "read_flag" (int): The read flag.
            - "addr" (int): The request ID.
            - "port" (int): The port number.
    """
    # Ensure the header length is correct
    expected_length = 1 + 1 + 4 + 4  # 1 byte (end_flag) + 1 byte (read_flag) + 4 bytes (addr)
    if len(header) != expected_length:
        raise ValueError(f"Header length is invalid. Expected {expected_length} bytes, got {len(header)} bytes.")
    
    # Unpack the header using the same format as `generate_header`
    unpacked_data = struct.unpack(">BBII", header)
    
    # Extract and format values
    end_flag = unpacked_data[0]  # End flag (1 byte)
    read_flag = unpacked_data[1]  # Read flag (1 byte)
    addr = unpacked_data[2]  # Address (4 bytes)
    port = unpacked_data[3]  # Port (4 bytes)
    
    return end_flag, read_flag, addr, port

class ClientServer:
    def __init__(self, ip_address:str, port_number:int, name:str):
        """
        Initializes a ClientServer instance.

        Parameters:
            ip_address (str): The IP address of the client server.
            public_key (str): The public key of the client server.
            private_key (str): The private key of the client server.
            port_number (int): The port number of the client server.
            name (str): The name of the client server.
        """
        self.ip_address = ip_address
        self.keys = {}
        self.port_number = port_number
        self.name = name
        
    def add_keys(self, public_key, private_key):
        """
        Adds the public and private keys to the client server.

        Parameters:
            public_key (str): The public key of the client server.
            private_key (str): The private key of the client server.
        """
        self.keys[public_key] = private_key
        
    def receive_encryption(self, encrypted_cycle, encrypted_message):
        """
        Receives an encrypted cycle and message from another client server.

        Parameters:
            encrypted_cycle (bytes): The encrypted cycle received from another client server.
            encrypted_message (bytes): The encrypted message received from another client server.
        """
        print('Decrypting cycle')
        ephemeral_public_key = encrypted_cycle[:32]
        private_key = self.keys[base64.b64encode(ephemeral_public_key)]
        encrypted = encrypted_cycle[32:]
        sealed_box = SealedBox(PrivateKey(base64.b64decode(private_key)))
        decrypted = sealed_box.decrypt(encrypted)
        
        end_flag, read_flag, addr, port = get_header_values(decrypted[:10])
        
        if read_flag == 1 and end_flag == 1:
            print(end_flag, read_flag, 'Request id:', addr, port)
            print("End of cycle")
            return read_flag, end_flag, addr, port, None, encrypted_message
        elif read_flag == 1:
            print(end_flag, read_flag, ip_int_to_str(addr), port)
            print('Received request')
            request = sealed_box.decrypt(encrypted_message)
            
            public_key = request[:32]
            message = request[32:]
            
            response = self.create_response(public_key, message)
            return read_flag, end_flag, addr, port, decrypted[10:], response
        else:
            print(end_flag, read_flag, ip_int_to_str(addr), port)
            return read_flag, end_flag, addr, port, decrypted[10:], encrypted_message

    def create_response(self,public_key, message):
        text_message = base64.b64decode(message.rstrip(b"\x00")).decode('utf-8')
        print('Received:', text_message)
        
        response = text_message
        print('Sending:', response)
        
        byte_array = bytes(bytearray(32) + create_byte_array(response))
        sealed_box = SealedBox(PublicKey(public_key))
        encrypted = sealed_box.encrypt(byte_array)
        return encrypted
